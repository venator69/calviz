<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Calviz</title>
</head>
<body>
  <div class="topnav" id="myTopnav">
    <a href="index.html" class="active">CALVIZ</a>
    <a href="index.html">Home</a>
    <a href="riemann.html">Riemann Integral</a>
    <a href="derivative.html">Derivative</a>
    <a href="limit.html">L'hospital</a>
    <a href="series.html">Taylor series</a>
    <a href="javascript:void(0);" class="icon">
      <i class="fa fa-bars"></i>
    </a>
  </div>

  <div class="card">
    <div class="typewriter">
      <div class="title">
        Introduction to Series
      </div>
    </div>
    <div class="subtitle">
      Infinite series
    </div>
    <div class="description">
      When you ask a computer or a calculator for the sine of an angle, or e to some
      power, it is using an algorithm to make this approximation. Many such algorithms
      are based on infinite series. An infinite series is a sum of infinitely many terms.
    </div>
    <div class="description">
      The infinite series converges for the following rules : 
    </div>
    <div class="description">
      <div class="image-container">
        <img src="assets/convergence.png" alt="convegence">
      </div>
    </div>
  </div>
  <div class="card">
    <div class="subtitle">
      Geometric Series
    </div>
    <div class="description">
      Geometric Series is a series of the form : Sn = a + ar + ar² +... + ar<sup>n-1</sup> = a(1-r<sup>n</sup>)/(1-r)
      where a is the first term, r is the common ratio, and n is the number of terms. The sum can also be represented
      by the formula in the figure below:
    </div>
    <div class="image-container">
      <img src="assets/partgeo.png" alt="partgeo">
    </div>
    <div class="description">
      If |r| < 1, lim x->inf of r<sup>n</sup> = 0, thus:
    </div>
    <div class="image-container">
      <img src="assets/geo.png" alt="sumgeo">
    </div>
  </div>
  
  <div class="card">
    <div class = "subtitle">
      Reconstructing Trancedentals
    </div>
    <div class="description">
      By integrating the geometric series, we got -ln(1 - x) = x + x<sup>2</sup>/2 + x<sup>3</sup>/3 + x<sup>4</sup>/4 + ...
    </div>
    <div class="description">
      By substituting -x for x, we got ln(1 + x) = x - x<sup>2</sup>/2 + x<sup>3</sup>/3 - x<sup>4</sup>/4 +...
    </div>
    <div class = "subtitle">
      Taylor Series
    </div>
    <div class="description">
      The major question still dangling is this: Given a function,
      can we represent it as a power series in x, or more generally, in x- a?
      More precisely, can we find numbers C<sub>0</sub>,C<sub>1</sub>,C<sub>2</sub>,C<sub>3</sub>,... such that:
    </div>
    <div class="description">
      f(x) = c<sub>0</sub> + c<sub>1</sub>(x - a) + c<sub>2</sub>(x - a)² + c<sub>3</sub>(x - a)³ +....
    </div>
    <div class="description">
      If such representation exists, by substituting x = a, we get :
    </div>
    <div class="description">c<sub>0</sub> = f(a)</div>
    <div class="description">c<sub>1</sub> = f'(a)</div>
    <div class="description">c<sub>2</sub> = f''(a)/(2!)</div>
    <div class="description">thus: c<sub>n</sub> = f<sup>[n]</sup>(a)/(n!)</div>
    <div class="description">
      To make it easier to evaluate, use MacLaurin series, which is a Taylor series at a = 0:
    </div>
  </div>



  <div class="card">
    <div class="subtitle">
      Maclaurin Series Visualisation
    </div>
    <div class="description">
      Select the functions:
      <select id="fnInput" class="selection">
        <option value="inv">y = 1/1-x</option>
        <option value="ln">y = ln(1-x)</option>
        <option value="exp">y = e^x</option>
        <option value="sin">y = sin(x)</option>
        <option value="cos">y = cos(x)</option>
        
      </select>
    </div>
    <div class="description">  
      <div class="margins">
        left margin:
        <input id="a" type="number" step="any" value="-4" class="selection" />
      </div>
      <div class="margins">
        right margin:
        <input id="b" type="number" step="any" value="4" class="selection"/>
      </div>
    </div>
    <div class="description">
      x: <span id="xLabel">0</span>
    </div>
    <div class="description">
      <input id="x" type="range" min="-2" max="2" value="0" step="0.1"/>
    </div>
    <div class="description">
      Number of terms: <span id="termsLabel">4</span>
    </div>
    <div class="description">
      <input id="terms" type="range" min="1" max="30" value="4" />
    </div>
    <canvas id="series" width="1000" height="400"></canvas>
    <div class="description">
    y approx = <b id="approx">-</b>, y exact = <b id="exact">-</b>,
    err = <b id="err">-</b>
    </div>
    <div class="description">
      Legend :
      <span style="color:red;">Red</span> is the Maclaurin approximation, <span style="color:blue;">Blue</span> is the real function.
    </div>
  </div>

  <div class="card">
    <div class="subtitle">Taylor Approximation</div>
    <div class="description">
      Using that properties we can now approximate many trancedental functions. With error function :  
    </div>
    <div class="image-container">
      <img src="assets/error.png" alt="error">
    </div>
  </div>

  <div class="social">
    <div class="content">
      <div class="subtitle">My Socials : </div>
    <div class="socials">
      <a href ="https://discord.com/users/864557474853290034">
        <div class="social-icons">
          <img src="assets/discord.png" alt="Profile picture"><span class="links">DISCORD</span>
        </div>
      </a>
      <a href ="https://www.instagram.com/kletka69420/?next=%2F">      
        <div class="social-icons">
          <img src="assets/ig.png" alt="ig"><span class="links">INSTAGRAM</span>
        </div>
      </a>
      <a href ="https://www.linkedin.com/feed/?trk=guest_homepage-basic_google-one-tap-submit">
        <div class="social-icons">
          <img src="assets/linkedin.png" alt="Profile picture"><span class="links">LINKEDIN</span>
        </div>
      </a>
      <a href="https://www.youtube.com/@transracialtrain9151">
        <div class="social-icons">
          <img src="assets/youtube.png" alt="Profile picture"><span class="links">YOUTUBE</span>
        </div>
      </a>
      <a href="https://github.com/venator69">
        <div class="social-icons">
          <img src="assets/github.png" alt="Profile picture"><span class="links">GITHUB</span>
        </div>
      </a>
    </div>
  </div>
<script>
const canvas = document.getElementById("series");
const ctx = canvas.getContext("2d");

// Input elements
const fnInput = document.getElementById('fnInput');
const aInput = document.getElementById('a');
const bInput = document.getElementById('b');
const xInput = document.getElementById('x');
const termsInput = document.getElementById('terms');
const termsLabel = document.getElementById('termsLabel');
const approx = document.getElementById('approx');
const exact = document.getElementById('exact');
const err = document.getElementById('err');
const xLabel = document.getElementById('xLabel');
/*************************************
          Helper Functions
**************************************/
function factorial(n) {
  return n <= 1 ? 1 : n * factorial(n - 1);
}

function mapX(x, a, b) {
  return (x - a) / (b - a) * canvas.width;
}

function mapY(y, minY, maxY) {
  return canvas.height - (y - minY) / (maxY - minY) * canvas.height;
}

function drawAxes(a, b, minY, maxY) {
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;

  // y-axis
  const x0 = (0 - a) / (b - a) * canvas.width;
  ctx.beginPath();
  ctx.moveTo(x0, 0);
  ctx.lineTo(x0+2, canvas.height);
  ctx.stroke();

  // x-axis
  const y0 = canvas.height - (-minY) / (maxY - minY) * canvas.height;
  ctx.beginPath();
  ctx.moveTo(0, y0);
  ctx.lineTo(canvas.width, y0+2);
  ctx.stroke();
}

/*************************************
        Maclaurin Series Functions
**************************************/
function MLInv(x, terms) {
  let sum = 0;
  for (let n = 0; n < terms; n++) sum += Math.pow(x, n);
  return sum;
}

function MLLn(x, terms) {
  let sum = 0;
  for (let n = 1; n <= terms; n++)
    sum += Math.pow(-1, n + 1) * Math.pow(x, n) / n;
  return sum;
}

function MLExp(x, terms) {
  let sum = 0;
  for (let n = 0; n < terms; n++)
    sum += Math.pow(x, n) / factorial(n);
  return sum;
}

function MLSin(x, terms) {
  let sum = 0;
  for (let n = 0; n < terms; n++)
    sum += Math.pow(-1, n) * Math.pow(x, 2 * n + 1) / factorial(2 * n + 1);
  return sum;
}

function MLCos(x, terms) {
  let sum = 0;
  for (let n = 0; n < terms; n++)
    sum += Math.pow(-1, n) * Math.pow(x, 2 * n) / factorial(2 * n);
  return sum;
}

/*************************************
          Function References
**************************************/
const fnMaclaurin = {
  inv: MLInv,
  ln:  MLLn,
  exp: MLExp,
  sin: MLSin,
  cos: MLCos,
};

const fnReal = {
  inv: (x) => 1 / (1 - x),
  ln:  (x) => Math.log(1 + x),
  exp: (x) => Math.exp(x),
  sin: (x) => Math.sin(x),
  cos: (x) => Math.cos(x),
};

/*************************************
          Drawing Functions
**************************************/
function drawSeries(fnM, fnR, a, b, terms) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Compute Y bounds
  let minY = Infinity, maxY = -Infinity;
  for (let i = 0; i <= 100; i++) {
    const xi = a + (b - a) * i / 100;
    const y = fnM(xi, terms);
    if (y > -500 && y < 500) { 
      if (y < minY) minY = y;
      if (y > maxY) maxY = y;
    }
  }
  const margin = 0.1 * (maxY - minY);
  minY -= margin;
  maxY += margin;


  drawAxes(a, b, minY, maxY);

  // Draw real function
  ctx.beginPath();
  for (let px = a; px <= b; px += 0.01) {
    const y = fnR(px);
    ctx.lineTo(mapX(px, a, b), mapY(y, minY, maxY));
  }
  ctx.strokeStyle = 'blue';
  ctx.stroke();

  // Draw Maclaurin approximation
  ctx.beginPath();
  for (let px = a; px <= b; px += 0.01) {
    const yApprox = fnM(px, terms);
    ctx.lineTo(mapX(px, a, b), mapY(yApprox, minY, maxY));
  }
  ctx.strokeStyle = 'red';
  ctx.stroke();

  // Draw cursor
  const x = parseFloat(xInput.value);
  const yApprox = fnM(x, terms);
  const y = fnR(x);
  
  ctx.fillStyle = "red"; // Real function
  ctx.fillRect(
    mapX(x, a, b) - 4,           // shift left by half the square width
    mapY(yApprox, minY, maxY) - 4, // shift up by half the square height
    8, 8
  );

  ctx.fillStyle = "blue"; // Real function
  ctx.fillRect(
    mapX(x, a, b) - 4,
    mapY(y, minY, maxY) - 4,
    8, 8
  );
}


/*************************************
          Update Function
**************************************/
function update() {
  const fn = fnInput.value;
  const fnM = fnMaclaurin[fn];
  const fnR = fnReal[fn];
  const a = parseFloat(aInput.value);
  const b = parseFloat(bInput.value);
  const x = parseFloat(xInput.value);
  const terms = parseInt(termsInput.value);

  termsLabel.textContent = terms;
  xLabel.textContent = x;

  const approxUp = fnM(x, terms);
  const exactUp = fnR(x);
  approx.textContent = approxUp.toExponential(3);
  exact.textContent = exactUp.toExponential(3);
  err.textContent = Math.abs(approxUp - exactUp).toExponential(3);
  xInput.min = a;
  xInput.max = b;
  drawSeries(fnM, fnR, a, b, terms);
}

/*************************************
          Event Listeners
**************************************/
[fnInput, aInput, bInput, xInput, termsInput].forEach(el =>
  el.addEventListener('input', update)
);

update();

// Toggle Burger Menu
function toggleBurger() {
  const topnav = document.getElementById("myTopnav");
  topnav.classList.toggle("responsive");
}

// Add click listener to burger icon
document.querySelector(".topnav .icon").addEventListener("click", toggleBurger);

</script>

</body>
</html>
